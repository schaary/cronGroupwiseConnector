#!/usr/bin/env ruby
# encoding: utf-8

$:.unshift File.expand_path('../../lib',__FILE__)

require 'awesome_print'
require 'colored'
require 'dotenv'
require 'mail'
require 'ruby-plsql'
require 'pry'
require 'thor'
require 'time'

require 'account'
require 'dispatcher'

# Das Script arbeitet in folgenden Schritten:
#
# 1. zuerst wird der Zeitpunkt des letzten Laufes des Scriptes bestimmt, um den
#    Zeitraum zu umreissen, aus dem alle Neueinträge gesammelt werden.
#    Dieser Zeitraum wird entweder über eine Variable --since an das Script
#    beim Aufruf übergeben oder es wird versucht, diesen Zeitpunkt aus der
#    Datenbank zu bestimmen. Jeder Scriptdurchlauf wird in der Tabelle
#    ma_log_tbl protokolliert. Dort wird nachgeschaut.
# 2. Anschliessend werden alle Einträge seit dem ermittelten Zeitstempel aus
#    der Datenbank geholt. 
# 3. Die Einträge aus der Datenbank werden in der Funktion 'transform' für die
#    Email aufbereitet und in den globalen Arrays @first_lines und @last_lines
#    abgelegt. 
# 4. Der Body der Mail wird aus den globalen Arrays @first_lines und
#    @last_lines bzw. - für die Löschmail - @delete_lines zusammen gestellt
# 5. Mail wird versendet.

class Notify < Thor
  method_option :since,
                desc: 'timestamp, since new mail addresses should be fetched'
  method_option :nolog,
                type: :boolean,
                default: false,
                desc: 'write no log about this run'
  desc 'send_add_sets','fetch the cursor with new mail addresss from idm'
  def send_add_sets
    @service = :add
    last_run_timestamp = parse_timestamp(since: options[:since])

    @first_lines = []
    @last_lines = []
    @ldif_add_lines = []
    fetch_add_sets since: last_run_timestamp
    transform

    mail_body = ""

    if 0 < @first_lines.length
      @first_lines.map do |line|
        mail_body << line << "\n"
      end

      @last_lines.map do |line|
        mail_body << line << "\n"
      end
    else
      mail_body = "Es liegen keine neuen Mail-Logins vor!"
    end

    mail_options = {
      address: 'localhost',
      port:    25,
      domain:  'uni-halle.de',
      enable_starttls_auto: false
    }

    Mail.defaults do 
      delivery_method :smtp, mail_options
    end

    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'postmaster@uni-halle.de'
      subject 'Subject: neue Mail-Logins'
      body    mail_body 
    end
    mail.deliver

    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'michael.schaarschmidt@itz.uni-halle.de'
      subject 'Subject: neue Mail-Logins'
      body    mail_body 
    end
    mail.deliver
    write_log

    mail_body = ""

    if 0 < @ldif_add_lines.length
      @ldif_add_lines.map do |line|
        mail_body << line << "\n"
      end
    else
      mail_body = "Es liegen keine neuen Mail-Logins vor!"
    end

    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'postmaster@uni-halle.de'
      subject 'Subject: neue Mail-Logins als LDIF'
      body    mail_body 
    end
    mail.deliver

    Mail.defaults do 
      delivery_method :smtp, mail_options
    end
    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'michael.schaarschmidt@itz.uni-halle.de'
      subject 'Subject: neue Mail-Logins als LDIF'
      body    mail_body 
    end
    mail.deliver
  end


  method_option :since,
                desc: 'timestamp, since new mail addresses should be fetched'
  method_option :nolog,
                type: :boolean,
                default: false,
                desc: 'write no log about this run'
  desc 'send_delete_sets','fetch the cursor with deleted mail addresss from idm'
  def send_delete_sets
    @service = :delete
    last_run_timestamp = parse_timestamp(since: options[:since])

    @delete_lines = []
    fetch_delete_sets since: last_run_timestamp
    transform

    mail_body = ""

    ap @delete_lines
    if 0 < @delete_lines.length
      @delete_lines.map do |line|
        mail_body << line << "\n"
      end
    else
      mail_body = "Es liegen keine zu loeschenden Mail-Adressen vor!"
    end

    mail_options = {
      address: 'localhost',
      port:    25,
      domain:  'uni-halle.de',
      enable_starttls_auto: false
    }

    Mail.defaults do 
      delivery_method :smtp, mail_options
    end

    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'postmaster@uni-halle.de'
      subject 'Subject: zu loeschende Mail-Adressen'
      body    mail_body 
    end
    mail.deliver

    mail = Mail.new do
      from    'michael.schaarschmidt@itz.uni-halle.de'
      to      'michael.schaarschmidt@itz.uni-halle.de'
      subject 'Subject: zu loeschende Mail-Adressen'
      body    mail_body 
    end
    mail.deliver

    write_log
  end
private
  def fetch_add_sets since: nil
    connect

    records = nil
    plsql.mail_pkg.fetchAddSets(since) { |c| records = c.fetch_all }

    @accounts = records.map do |record|
      cast_to_add_account(record)
    end
  end

  def fetch_delete_sets since: nil
    connect

    records = nil
    plsql.mail_pkg.fetchDeleteSets(since) { |c| records = c.fetch_all }

    @accounts = records.map do |record|
      cast_to_delete_account(record)
    end
  end

  def parse_timestamp since: nil
    return last_run if since.nil?

    unless since.match(/\A[0-9]{2}\.[0-9]{2}\.[0-9]{4}\s[0-9]{2}:[0-9]{2}\z/)
      abort error "Das angegebene Datumsformat kann nicht geparsed werden. " + 
                  "Versuche: '01.03.1972 07:24'"
    end

    begin
      DateTime.strptime(since,'%d.%m.%Y %H:%M').to_time
    rescue => e
    end
  end

  def last_run
    connect
    if :add == @service then
      plsql.ma_pkg.lastRun(2,1)
    elsif :delete == @service then
      plsql.ma_pkg.lastRun(2,3)
    else
      abort error "last_run kann nur für add oder delete abgefragt werden"
    end
  end

  def error msg
    error_prefix = "[" + "error".red + "] "
    error_prefix + msg
  end

  def write_log
    unless options[:nolog]
      if :add == @service
        return_value = plsql.ma_pkg.writeLog(2, 1, 0)
      elsif :delete == @service
        return_value = plsql.ma_pkg.writeLog(2, 3, 0)
      else
        abort error "last_run kann nur für add oder delete abgefragt werden"
      end
    end
  end

  def cast_to_add_account(record)
    account = Account.new
    account.id = record[0].to_i
    account.uid = record[1].strip
    account.lastname = record[2].strip
    account.firstname = record[3]
    account.account_type = record[5]
    account.mail = record[6].strip
    account.uid_number = record[7]
    account.gid_number = record[8]
    account.password = record[9].strip

    account.freeze
  end

  def cast_to_delete_account(record)
    account = Account.new
    account.uid = record[0].strip
    account.mail = record[1].strip

    account.freeze
  end

  def transform
    dispatcher = Dispatcher.new
    if :add == @service
      @accounts.map do |account|
        @first_lines << dispatcher.dispatch_first_line(account: account)
      end
      @accounts.map do |account|
        @last_lines << dispatcher.dispatch_last_line(account: account)
      end
      @accounts.map do |account|
        @ldif_add_lines << dispatcher.dispatch_ldif_add_line(account: account)
      end
    elsif :delete == @service
      @accounts.map do |account|
        @delete_lines << dispatcher.dispatch_delete_line(account: account)
      end
    else
      abort error "last_run kann nur für add oder delete abgefragt werden"
    end
  end

  def connect
    Dotenv.load

    plsql.connection ||= OCI8.new \
      ENV['IDM_USERNAME'],
      ENV['IDM_PASSWORD'],
      ENV['IDM_SID']
  end
end

Notify.start
